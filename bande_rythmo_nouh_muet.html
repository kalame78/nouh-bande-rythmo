<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Bande Rythmo — Dialogue de Nouh (muet)</title>
<style>
  :root {
    --bg: #000000;
    --text: #fbc576; /* doré clair */
    --dim: #9b7a46; /* nuance douce */
    --bar: #ff2b2b; /* trait rouge vertical */
    --band-height: 160px;
    --font: "TT Forms", "Montserrat", system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
  }

  html, body {
    height: 100%;
    margin: 0;
    background: var(--bg);
    color: var(--text);
    font-family: var(--font);
  }

  .stage {
    display: grid;
    grid-template-rows: 1fr var(--band-height) auto;
    height: 100%;
  }

  .title {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
    text-align: center;
    opacity: 0.9;
  }
  .title h1 {
    font-size: clamp(18px, 2.6vw, 28px);
    margin: 0;
    font-weight: 600;
    letter-spacing: 0.3px;
  }

  .band-wrap {
    position: relative;
    overflow: hidden;
    border-top: 1px solid rgba(255,255,255,0.08);
    border-bottom: 1px solid rgba(255,255,255,0.08);
    background: linear-gradient(to bottom, rgba(255,255,255,0.02), rgba(255,255,255,0));
  }

  /* Trait rouge vertical (curseur rythmo) */
  .cursor {
    position: absolute;
    top: 0;
    bottom: 0;
    left: 50%;
    width: 2px;
    background: var(--bar);
    transform: translateX(-1px);
    box-shadow: 0 0 12px rgba(255, 43, 43, 0.6);
    z-index: 5;
  }

  .line {
    position: absolute;
    left: 0;
    top: 50%;
    transform: translateY(-50%);
    white-space: nowrap;
    will-change: transform;
    padding: 0 50vw; /* marge interne pour laisser entrer/sortir le texte */
  }

  .line span {
    display: inline-block;
    font-size: clamp(18px, 2.2vw, 34px);
    line-height: 1.4;
    margin: 0 0.35em;
    color: var(--dim);
    transition: color 120ms linear, text-shadow 120ms linear;
  }
  .line span.active {
    color: var(--text);
    text-shadow: 0 0 6px rgba(251, 197, 118, 0.35);
  }

  .controls {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 12px;
    padding: 14px 10px 24px;
  }
  .btn {
    background: rgba(255,255,255,0.06);
    border: 1px solid rgba(255,255,255,0.08);
    color: #fff;
    padding: 10px 16px;
    border-radius: 10px;
    cursor: pointer;
    font-size: 14px;
    letter-spacing: 0.3px;
  }
  .btn:hover { background: rgba(255,255,255,0.1); }
  .time {
    font-variant-numeric: tabular-nums;
    opacity: 0.8;
  }

  .credit {
    text-align: center;
    opacity: 0.6;
    font-size: 12px;
    padding-bottom: 10px;
  }
</style>
</head>
<body>
  <div class="stage">
    <div class="title">
      <h1>Bande Rythmo — Dialogue de Nouh (muet, texte défilant & trait rouge fixe)</h1>
    </div>

    <div class="band-wrap" id="band">
      <div class="cursor" aria-hidden="true"></div>
      <!-- ligne injectée dynamiquement -->
      <div class="line" id="line"></div>
    </div>

    <div class="controls">
      <button class="btn" id="play">▶︎ Lecture</button>
      <button class="btn" id="pause">⏸ Pause</button>
      <button class="btn" id="restart">↺ Recommencer</button>
      <span class="time" id="clock">00:00</span>
    </div>
    <div class="credit">Texte FR et synchronisation visuelle basés sur ton extrait — prêt pour hébergement GitHub Pages, intégration Canva/Genially (iframe).</div>
  </div>

<script>
const SEGMENTS = [{"start": "7:18", "end": "7:20", "duration": 2, "text": "Le fou !"}, {"start": "7:20", "end": "7:21", "duration": 1, "text": "Le fou !"}, {"start": "7:21", "end": "7:24", "duration": 3, "text": "Que veux-tu de nous, Noé ?"}, {"start": "7:24", "end": "7:26", "duration": 2, "text": "Nous voulons adorer ton Dieu."}, {"start": "7:26", "end": "7:29", "duration": 3, "text": "Nous n’avons pas besoin de Lui."}, {"start": "7:29", "end": "7:31", "duration": 2, "text": "Nous n’adorons que nos propres divinités."}, {"start": "7:31", "end": "7:32", "duration": 1, "text": "Va-t’en d’ici !"}, {"start": "7:32", "end": "7:35", "duration": 3, "text": "Tu es un fou, Noé !"}, {"start": "7:35", "end": "7:43", "duration": 8, "text": "Le prophète de Dieu, Noé, se leva et appela son peuple à l’unicité d’Allah,"}, {"start": "7:43", "end": "7:46", "duration": 3, "text": "et à n’adorer que Lui, le Seul et l’Unique."}, {"start": "7:46", "end": "8:22", "duration": 36, "text": "Mais ils lui tournèrent le dos et mirent leurs doigts dans leurs oreilles."}, {"start": "8:22", "end": "8:27", "duration": 5, "text": "Ce conflit éternel entre la vérité et le faux demeurera à jamais."}, {"start": "8:27", "end": "8:30", "duration": 3, "text": "Noé fut patient et endurant ;"}, {"start": "8:30", "end": "8:33", "duration": 3, "text": "il était parmi les plus résolus des messagers."}, {"start": "8:33", "end": "8:36", "duration": 3, "text": "Et pourtant, son peuple persista dans l’égarement."}, {"start": "8:36", "end": "8:38", "duration": 2, "text": "Ils adoraient toujours leurs idoles,"}, {"start": "8:38", "end": "9:01", "duration": 23, "text": "et leurs cœurs rebelles refusaient d’écouter les paroles de Noé."}, {"start": "9:01", "end": "9:05", "duration": 4, "text": "Noé ne cessa d’appeler les gens à l’unicité divine,"}, {"start": "9:05", "end": "9:09", "duration": 4, "text": "à délaisser l’adoration des idoles."}, {"start": "9:09", "end": "9:31", "duration": 22, "text": "Cette épreuve dura pour Noé (paix sur lui) et ses fidèles tout au long de sa mission : quitter l’idolâtrie et entrer dans la religion de la vérité."}, {"start": "9:31", "end": "9:39", "duration": 8, "text": "Noé, le prophète patient et persévérant, appela son peuple jour et nuit."}, {"start": "9:39", "end": "9:44", "duration": 5, "text": "Mais ils se détournèrent encore du commandement d’Allah."}, {"start": "9:44", "end": "9:47", "duration": 3, "text": "Quelle tragédie !"}, {"start": "9:47", "end": "9:54", "duration": 7, "text": "Ils ne réalisaient pas qu’un prophète d’Allah se tenait parmi eux."}, {"start": "9:54", "end": "10:00", "duration": 6, "text": "Et Noé, avec patience et foi, les appela encore au pardon : « Seigneur ! Pardonne à mon peuple, car ils ne savent pas. »"}];

// Utilities
function mmssToSeconds(mmss) {
  const [m, s] = mmss.split(':').map(Number);
  return m*60 + s;
}
function pad(n) { return String(n).padStart(2, '0'); }
function formatClock(sec) {
  const s = Math.max(0, Math.floor(sec));
  return pad(Math.floor(s/60)) + ':' + pad(s%60);
}

// Compute a continuous schedule starting at t=0
const schedule = [];
let t0 = 0;
for (const seg of SEGMENTS) {
  const words = seg.text.trim().split(/\s+/);
  const duration = seg.duration;
  const tStart = t0;
  const tEnd = t0 + duration;
  schedule.push({
    text: seg.text,
    words,
    tStart,
    tEnd,
    duration
  });
  t0 = tEnd; // chain segments
}
const totalDuration = t0;

const band = document.getElementById('band');
const line = document.getElementById('line');
const btnPlay = document.getElementById('play');
const btnPause = document.getElementById('pause');
const btnRestart = document.getElementById('restart');
const clock = document.getElementById('clock');

let raf = null;
let isPlaying = false;
let startEpoch = 0;    // performance.now() at (resumed) start
let pausedAt = 0;      // time (s) where we paused
let currentTime = 0;   // continuous time 0..totalDuration

// Build the line for a given segment
function setLineText(words) {
  line.innerHTML = '';
  for (const w of words) {
    const span = document.createElement('span');
    span.textContent = w.replaceAll('|', ''); // safety
    line.appendChild(span);
  }
  // ensure it's well left outside initially
  line.style.transform = 'translate(-9999px, -50%)';
}

// Return layout centers (x positions) of each word span
function measureWordCenters() {
  const spans = Array.from(line.querySelectorAll('span'));
  const rectLine = line.getBoundingClientRect();
  return spans.map(sp => sp.getBoundingClientRect().left - rectLine.left + sp.getBoundingClientRect().width/2);
}

// Given a segment and elapsed time inside it, compute desired translateX to align interpolation word center with cursor
function computeTranslateX(segLayout, elapsed, segDuration) {
  const centers = segLayout.centers;
  const n = centers.length;
  if (n === 0) return 0;
  const cursorX = band.clientWidth / 2; // center
  // Word timing: uniform per-word across segment
  const step = segDuration / n;
  const idxFloat = Math.min(n - 1 + 1e-6, Math.max(0, elapsed / step));
  const i = Math.floor(idxFloat);
  const f = idxFloat - i;
  const c0 = centers[Math.min(i, n-1)];
  const c1 = centers[Math.min(i+1, n-1)];
  const c = c0 + (c1 - c0) * f;
  // We want center c to coincide with cursor => translateX = cursor - c
  return (cursorX - c);
}

// Activate the "active" word by time
function updateActiveWord(segLayout, elapsed, segDuration) {
  const spans = segLayout.spans;
  const n = spans.length;
  if (!n) return;
  const step = segDuration / n;
  const idx = Math.min(n-1, Math.max(0, Math.floor(elapsed / step)));
  spans.forEach((sp, k) => sp.classList.toggle('active', k === idx));
}

// Main animation loop
let segIndex = 0;
let segLayout = null; // { spans, centers, duration }
function render() {
  if (!isPlaying) return;
  const now = performance.now();
  currentTime = pausedAt + (now - startEpoch) / 1000;
  if (currentTime >= totalDuration) currentTime = totalDuration;
  clock.textContent = formatClock(currentTime);

  // Determine current segment
  while (segIndex < schedule.length && currentTime >= schedule[segIndex].tEnd - 1e-6) {
    segIndex++;
    segLayout = null;
  }
  if (segIndex >= schedule.length) {
    isPlaying = false;
    cancelAnimationFrame(raf);
    return;
  }

  const seg = schedule[segIndex];
  const elapsed = currentTime - seg.tStart;
  if (!segLayout) {
    // Initialize layout for this segment
    setLineText(seg.words);
    const spans = Array.from(line.querySelectorAll('span'));
    const centers = measureWordCenters();
    segLayout = { spans, centers, duration: seg.duration };
  }

  // Compute transform
  const tx = computeTranslateX(segLayout, Math.max(0, elapsed), seg.duration);
  // Translate the line so the current word center hits the cursor
  line.style.transform = `translate({tx}px, -50%)`;

  // Update active word highlighting
  updateActiveWord(segLayout, Math.max(0, elapsed), seg.duration);

  // When segment ends, fade out briefly to avoid jump
  if (elapsed >= seg.duration - 0.02) {
    // prepare next segment line off-screen; actual swap happens on next loop
  }

  raf = requestAnimationFrame(render);
}

// Controls
btnPlay.addEventListener('click', () => {
  if (isPlaying) return;
  isPlaying = true;
  startEpoch = performance.now();
  render();
});

btnPause.addEventListener('click', () => {
  if (!isPlaying) return;
  isPlaying = false;
  pausedAt = currentTime;
  cancelAnimationFrame(raf);
});

btnRestart.addEventListener('click', () => {
  isPlaying = false;
  cancelAnimationFrame(raf);
  pausedAt = 0;
  currentTime = 0;
  clock.textContent = '00:00';
  segIndex = 0;
  segLayout = null;
  // Reset line content to first segment words
  setLineText(schedule[0].words);
});

// Initialize with first line ready
setLineText(schedule[0].words);
</script>
</body>
</html>
